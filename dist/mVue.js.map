{"version":3,"file":"mVue.js","sources":["webpack:///webpack/bootstrap","webpack:///./src/Compile.js","webpack:///./src/Dep.js","webpack:///./src/Observer.js","webpack:///./src/Watcher.js","webpack:///./src/index.js","webpack:///./src/parseExpression.js","webpack:///./src/utils/classAttrUtil.js","webpack:///./src/utils/insertAfter.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import Watcher from './Watcher'\r\nimport parseExpression from './parseExpression'\r\nimport classAttrUtil from './utils/classAttrUtil'\r\nimport insertAfter from './utils/insertAfter'\r\n\r\n// 插值{{}}正则\r\nconst interpolationReg = /\\{\\{([^\\}\\}]+)\\}\\}/\r\n// 事件参数正则\r\nconst eventArgsReg = /\\((.*)\\)/\r\n// v-for指令正则\r\nconst vForReg = /(.*)\\sin\\s(.*)/\r\n\r\nfunction Compile(el,vm){\r\n\tthis.$vm = vm;\r\n\tthis.$el = this.isElementNode(el) ? el : document.querySelector(el);\r\n\tthis.init(this.$el);\r\n}\r\n\r\nCompile.prototype = {\r\n\tconstrutor:Compile,\r\n\tinit:function(el){\r\n\t\tif (el){\r\n\t\t\tvar fragment = this.node2Fragment(el);\r\n\t\t\tthis.compileElement(fragment);\r\n\t\t\tthis.$el.appendChild(fragment);\r\n\t\t}\r\n\t},\r\n\t// 文档碎片拷贝\r\n\tnode2Fragment: el => {\r\n        var fragment = document.createDocumentFragment(),\r\n            child;\r\n\r\n        while(child = el.firstChild){\r\n        \tfragment.appendChild(child);\r\n        }\r\n\r\n        return fragment;\r\n\t},\r\n\tcompileElement:function(el){\r\n\t\tvar child = el.childNodes;\r\n\t\tvar reg = /\\{\\{(.*)\\}\\}/;\r\n\t\tfor (let key of child){\r\n\t\t\t// 判断元素\r\n\t\t\tif (this.isElementNode(key)){\r\n\t\t\t\tthis.compile(key);\r\n\t\t\t}\r\n\t\t\t// 判断是否是插值表达式\r\n\t\t\telse if (this.isTextNode(key) && interpolationReg.test(key.textContent)){\r\n\t\t\t\tthis.compileText(key)\r\n\t\t\t}\r\n\t\t\t// 子节点编译\r\n\t\t\tif (key.childNodes && key.childNodes.length){\r\n\t\t\t\tthis.compileElement(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tcompile:function (node){\r\n\t\tvar nodeAttrs = node.attributes;\r\n\t\t[...nodeAttrs].forEach( key => {\r\n\t\t\tlet name = key.nodeName,\r\n\t\t\t\tval = key.nodeValue;\r\n\t\t\t// v- 指令\r\n\t\t\tif (this.isDirective(name)){\r\n\t\t\t\tlet dir = name.substring(2);\r\n\t\t\t\tif (dir === 'model') {\r\n\t\t\t\t\tcompileUtil.model(node,this.$vm,val);\r\n\t\t\t\t}\r\n\t\t\t\telse if (dir === 'for') {\r\n\t\t\t\t\tvForReg.test(val) && compileUtil.vForBind(node,this.$vm,val);\r\n\t\t\t\t}\r\n                else {\r\n                    compileUtil.bind(node,this.$vm,val,dir);\r\n                }\r\n\t\t\t\tnode.removeAttribute(name);\r\n\t\t\t}\r\n\t\t\t// @ 事件指令\r\n\t\t\tif (this.isEventDirective(name)){\r\n\t\t\t\tlet event = name.substring(1);\r\n                let fnName = val\r\n                let argList = []\r\n                // 判断绑定的函数里有没有参数\r\n                let matchRes = val.match(eventArgsReg)\r\n                if (matchRes) {\r\n                    fnName = val.substring(0,matchRes.index)\r\n                    argList = matchRes[1].split(',')\r\n                }\r\n\t\t\t\tcompileUtil.eventHandler(node,this.$vm,event,fnName,argList);\r\n\t\t\t\tnode.removeAttribute(name);\r\n\t\t\t}\r\n            // 属性绑定\r\n            if (this.isAttrDirective(name)) {\r\n                let attr = name.substring(1)\r\n                compileUtil.attrBind(node,this.$vm,attr,val);\r\n                node.removeAttribute(name);\r\n            }\r\n\t\t})\r\n\t},\r\n    // 编译插值表达式\r\n\tcompileText:function(node){\r\n        let matchRes = null\r\n        let expList = []\r\n        let gReg = new RegExp(interpolationReg,'g')\r\n        while (matchRes = gReg.exec(node.textContent)) {\r\n            expList.push(matchRes[1])\r\n        }\r\n        compileUtil.braceBind(node, this.$vm, expList)\r\n\t},\r\n\tisElementNode: el => {\r\n\t\treturn el.nodeType === 1;\r\n\t},\r\n\tisTextNode: el => {\r\n\t\treturn el.nodeType === 3;\r\n\t},\r\n    // 是否是指令\r\n\tisDirective: attr => {\r\n\t\treturn attr.indexOf('v-') === 0;\r\n\t},\r\n    // 是否是事件绑定\r\n\tisEventDirective: attr => {\r\n\t\treturn attr.indexOf('@') === 0;\r\n\t},\r\n    // 是否是属性绑定\r\n    isAttrDirective: val => val.indexOf(':') === 0\r\n}\r\n\r\n// 指令处理集合\r\nvar compileUtil = {\r\n    model: function(node, vm, val) {\r\n        this.bind(node, vm, val, 'model');\r\n\r\n\t\tvar cpLock = false,\r\n\t\t\tself = this;\r\n\r\n        node.addEventListener('compositionstart', function(){\r\n            cpLock = true;\r\n        })\r\n        node.addEventListener('input',Func);\r\n        node.addEventListener('compositionend', function(e){\r\n            cpLock = false;\r\n            Func(e);\r\n        })\r\n\r\n        function Func(e){\r\n            if (!cpLock){\r\n                var newValue = e.target.value;\r\n                self.setVMVal(vm, val, newValue);\r\n            }\r\n        }\r\n    },\r\n    bind:function(node,vm,val,dir){\r\n    \tvar value = this.getVMVal(vm,val);\r\n    \tthis.dirHandler(node,value,dir);\r\n    \t// 实例化一个watcher对象和回调函数\r\n    \tnew Watcher(vm,val,(newVal) => {\r\n    \t\tthis.dirHandler(node,newVal,dir);\r\n    \t})\r\n    },\r\n    // 事件处理\r\n    eventHandler:function(node,vm,event,fnName,argList){\r\n    \tlet fn = vm[fnName]\r\n    \tif (fn && event){\r\n    \t\t// 绑定@函数\r\n    \t\tnode.addEventListener(event,() => {\r\n                fn.apply(vm,argList.map(item => this.getVMVal(vm, item)))\r\n            });\r\n    \t}\r\n    },\r\n    // 插值绑定\r\n    braceBind: function (node, vm, expList) {\r\n        let backupText = node.textContent\r\n        this.braceHandler(node, vm, backupText)\r\n        expList.forEach(exp => {\r\n            // 实例化一个watcher对象和回调函数\r\n            new Watcher(vm, exp, newVal => {\r\n                this.braceHandler(node, vm, backupText)\r\n            })\r\n        })\r\n    },\r\n    // 插值处理\r\n    braceHandler: function (node, vm, backupText) {\r\n        node.textContent = backupText.replace(new RegExp(interpolationReg,'g'),(val,p1) => {\r\n            return this.getVMVal(vm,p1)\r\n        })\r\n    },\r\n    // 属性绑定\r\n    attrBind(node, vm, type, exp) {\r\n        if (type === 'class') {\r\n            let {res,isSameJson,isSameArr} = classAttrUtil(exp)\r\n            if (isSameJson) {\r\n                res.forEach(item => {\r\n                    this.attrHandler(node,{\r\n                        type: (this.getVMVal(vm, item.nameExp) ? 'add' : 'remove'),\r\n                        class: item.name,\r\n                    }, type)\r\n                    new Watcher(vm, item.nameExp, newValue => {\r\n                        this.attrHandler(node,{\r\n                            type: (newValue ? 'add' : 'remove'),\r\n                            class: item.name,\r\n                        }, type)\r\n                    })\r\n                })\r\n            }\r\n            else if (isSameArr) {\r\n                res.forEach(item => {\r\n                    this.attrHandler(node,{\r\n                        type: 'add',\r\n                        class: this.getVMVal(vm, item),\r\n                    }, type)\r\n                    new Watcher(vm, item, (newValue,oldValue) => {\r\n                        this.attrHandler(node,{\r\n                            type: 'add',\r\n                            class: newValue,\r\n                        }, type)\r\n                        this.attrHandler(node,{\r\n                            type: 'remove',\r\n                            class: oldValue,\r\n                        }, type)\r\n                    })\r\n                })\r\n            }\r\n            else {\r\n                throw(`${exp} 无效的class绑定`)\r\n            }\r\n        }\r\n        else {\r\n            this.attrHandler(node, this.getVMVal(vm, exp), type)\r\n            new Watcher(vm, exp, newValue => {\r\n                this.attrHandler(node, newValue, type)\r\n            })\r\n        }\r\n    },\r\n    // 属性处理\r\n    attrHandler: function(node,val,type) {\r\n        if (type === 'class') {\r\n            node.classList[val.type](val.class)\r\n        }\r\n        else {\r\n            node.setAttribute(type,val)\r\n        }\r\n    },\r\n    // v-for指令绑定\r\n    vForBind(node, vm, val) {\r\n        let [,forKey,forVal] = val.match(vForReg)\r\n        let vmVal = this.getVMVal(vm, forVal)\r\n        this.dirForHandler(node, vmVal)\r\n    },\r\n    // v-for指令处理\r\n    dirForHandler(node,val) {\r\n        // console.log(node,val)\r\n        for (let i in val) {\r\n            if (val.hasOwnProperty(i)) {\r\n                insertAfter(node,node)\r\n            }\r\n        }\r\n    },\r\n    // 指令处理\r\n    dirHandler:function(node,val,type){\r\n    \tswitch (type){\r\n    \t\tcase \"text\":\r\n    \t\t\tnode.innerText = val || '';\r\n    \t\t\tbreak;\r\n    \t\tcase \"html\":\r\n    \t\t\tnode.innerHTML = val || '';\r\n    \t\t\tbreak;\r\n    \t\tcase \"show\":\r\n    \t\t\tif (typeof val == 'undefined'){\r\n    \t\t\t\tnode.style.display = '';\r\n    \t\t\t}\r\n    \t\t\telse {\r\n    \t\t\t\tnode.style.display = val ? '' : \"none\";\r\n    \t\t\t}\r\n    \t\t\tbreak;\r\n    \t\tcase \"hide\":\r\n    \t\t\tif (typeof val == 'undefined'){\r\n    \t\t\t\tnode.style.display = '';\r\n    \t\t\t}\r\n    \t\t\telse {\r\n    \t\t\t\tnode.style.display = val ? 'none' : \"\";\r\n    \t\t\t}\r\n    \t\t\tbreak;\r\n    \t\tcase \"model\":\r\n    \t\t\tnode.value = val || '';\r\n    \t\t\tbreak;\r\n    \t}\r\n    },\r\n    setVMVal:function(vm, val, newValue){\r\n    \tnew Function(\"this.\"+val+\"=\\'\"+newValue+\"\\'\").apply(vm);\r\n    },\r\n    getVMVal:function(vm,val){\r\n\t\treturn parseExpression(val,vm)\r\n    }\r\n}\r\n\r\n\r\nexport default Compile","\r\nvar uid = 0;\r\n\r\nfunction Dep() {\r\n    // 依赖数组\r\n    this.subs = [];\r\n     // 添加唯一值\r\n    this.id = ++uid;\r\n}\r\nDep.prototype = {\r\n    // 导入依赖数组\r\n    addSub: function(sub){\r\n        this.subs.push(sub);\r\n    },\r\n    // 收集依赖\r\n    depend: function(){\r\n        // Compile初始化也会触发get方法，但此时Dep.target为null\r\n        // 触发Watcher里面的getVMVal时，Dep.target有值，是Watcher的当前实例\r\n        // Watcher line 42\r\n        if (Dep.target) {\r\n            // Watcher addDep执行\r\n            Dep.target.addDep(this);\r\n        }\r\n    },\r\n    // 触发依赖\r\n    notify: function(){\r\n        console.log('发布者发布-----');\r\n        this.subs.forEach(sub => {\r\n            // 执行Watcher 里面的update方法\r\n            sub.update();\r\n        });\r\n    }\r\n};\r\n\r\nDep.target = null;\r\n\r\nexport default Dep\r\n","import Dep from './Dep'\r\n\r\n\r\nfunction Observer(data) {\r\n    this.data = data;\r\n    this.beforeInt();\r\n};\r\n\r\nObserver.prototype = {\r\n    constructor:Observer,\r\n    beforeInt:function (){\r\n        var data = this.data;\r\n        if (!data || typeof data !== 'object') {\r\n            return;\r\n        }\r\n        this.init();\r\n    },\r\n    init: function(){\r\n        var data = this.data;\r\n        // 取出所有属性遍历\r\n        Object.keys(data).forEach(key => {\r\n            this.defineReactive(data, key, data[key]);\r\n        });\r\n    },\r\n    defineReactive: function(data,key,val){\r\n        var dep = new Dep();\r\n        new Observer(val); // 监听子属性\r\n\r\n        Object.defineProperty(data, key, {\r\n            enumerable: true, // 可枚举\r\n            configurable: false, // 不能再define\r\n            get: () => {\r\n                // 收集依赖\r\n                dep.depend();\r\n                return val;\r\n            },\r\n            set: newVal => {\r\n                if (val === newVal) return;\r\n                console.log('监听到值变化了 ', val, ' --> ', newVal);\r\n                val = newVal;\r\n                new Observer(newVal);\r\n                // 触发依赖\r\n                dep.notify();\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n\r\nexport default Observer\r\n","import Dep from './Dep'\r\nimport parseExpression from './parseExpression'\r\n/**\r\n * [Watcher description]\r\n * @Author leegsen\r\n * @time   2018-03-29T11:18:01+0800\r\n * @param  {[type]}                 vm  [实例对象]\r\n * @param  {[type]}                 exp [表达式]\r\n * @param  {Function}               cb  [回调函数]\r\n */\r\nlet uid = 0\r\n\r\nfunction Watcher(vm,exp,cb){\r\n\tthis.vm = vm;\r\n\tthis.exp = exp;\r\n\tthis.cb = cb;\r\n\tthis.dep = []\r\n\tthis.newDepIds = {}\r\n\tthis.depIds = {};\r\n\tthis.uid = ++uid\r\n\tthis.value = this.get();\r\n}\r\n\r\nWatcher.prototype = {\r\n\tconstructor:Watcher,\r\n\t// observer setter 更新\r\n\tupdate:function(){\r\n\t\tvar oldVal = this.value\r\n\t\tvar newVal = this.get()\r\n\t\t // 值发生改变就赋值回调\r\n\t\tif (oldVal !== newVal) {\r\n\t\t\tthis.value = newVal;\r\n\t\t\ttypeof this.cb === 'function' && this.cb.call(this.vm,newVal,oldVal);\r\n\t\t\tthis.dep.forEach(item => {\r\n\t\t\t\titem.update()\r\n\t\t\t})\r\n\t\t}\r\n\t},\r\n    // 判断和收集依赖\r\n    addDep: function (dep) {\r\n    \t// 判断是否是收集过的依赖\r\n     \t// 没有这个id属性，说明是新的属性\r\n     \tif (!this.depIds.hasOwnProperty(dep.id)){\r\n            // 将此时的实例对象添加到订阅者数组中\r\n            dep.addSub(this);\r\n            this.depIds[dep.id] = dep;\r\n     \t}\r\n    },\r\n    depend() {\r\n    \tif (!this.newDepIds.hasOwnProperty(this.uid)) {\r\n    \t\tthis.newDepIds[this.uid] = this.uid\r\n    \t\tthis.dep.push(Dep.target)\r\n    \t}\r\n    },\r\n\t// 触发observer getter\r\n\tget:function(){\r\n\t\tDep.target = this;\r\n\t\t// 这个方法会取值会触发Object.defineProperty get方法\r\n\t\t// Observer line 32\r\n\t\tvar value = this.getVMVal();\r\n\t\tDep.target = null;\r\n\t\treturn value;\r\n\t},\r\n\tgetVMVal:function(){\r\n\t\treturn (typeof this.exp === 'function' ? this.exp.call(this.vm) : parseExpression(this.exp, this.vm))\r\n\t}\r\n}\r\n\r\nexport default Watcher\r\n","import Observer from './Observer'\r\nimport Compile from './Compile'\r\nimport Watcher from './Watcher'\r\nimport Dep from './Dep'\r\n\r\nfunction Vue(options){\r\n\tthis.$options = options;\r\n\tthis.$data = this.$options.data();\r\n\r\n    new Observer(this.$data);\r\n    this.$proxy()\r\n    this.initComputed()\r\n\tnew Compile(this.$options.el || document.body,this);\r\n}\r\n// 把data,method代理到当前实例上去\r\nVue.prototype.$proxy = function() {\r\n    for (let key in this.$data) {\r\n        Object.defineProperty(this, key, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: () => {\r\n                return this.$data[key]\r\n            },\r\n            set: newVal => {\r\n                this.$data[key] = newVal\r\n            }\r\n        });\r\n    }\r\n    for (let key in this.$options.methods) {\r\n        this[key] = this.$options.methods[key]\r\n    }\r\n}\r\n// 初始化属性计算\r\nVue.prototype.initComputed = function() {\r\n    let {computed} = this.$options\r\n    if (typeof computed === 'object') {\r\n        for (let key in computed) {\r\n            let item = computed[key]\r\n            if (typeof item === 'function') {\r\n                Object.defineProperty(this, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    get: makeComputedGetter(item, this),\r\n                    set: () => {},\r\n                })\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction makeComputedGetter(fn, owner) {\r\n    let watcher = new Watcher(owner, fn, null)\r\n    return function computedGetter() {\r\n        if (Dep.target) {\r\n            watcher.depend()\r\n        }\r\n        return watcher.value\r\n    }\r\n}\r\n\r\nwindow.Vue = Vue\r\n\r\nexport default Vue\r\n","/**\r\n * 计算表达式的值,代码来自vue源码src/parsers/expression.js\r\n */\r\n\r\nconst allowedKeywords =\r\n    'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\r\n    'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\r\n    'encodeURIComponent,parseInt,parseFloat'\r\nconst allowedKeywordsRE =\r\n    new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\r\n\r\nconst wsRE = /\\s/g\r\nconst newlineRE = /\\n/g\r\nconst saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\\"']|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g\r\nconst restoreRE = /\"(\\d+)\"/g\r\nconst pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/\r\nconst identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g\r\nconst literalValueRE = /^(?:true|false|null|undefined|Infinity|NaN)$/\r\n\r\n/**\r\n * Save / Rewrite / Restore\r\n *\r\n * When rewriting paths found in an expression, it is\r\n * possible for the same letter sequences to be found in\r\n * strings and Object literal property keys. Therefore we\r\n * remove and store these parts in a temporary array, and\r\n * restore them after the path rewrite.\r\n */\r\n\r\nvar saved = []\r\n\r\n/**\r\n * Save replacer\r\n *\r\n * The save regex can match two possible cases:\r\n * 1. An opening object literal\r\n * 2. A string\r\n * If matched as a plain string, we need to escape its\r\n * newlines, since the string needs to be preserved when\r\n * generating the function body.\r\n *\r\n * @param {String} str\r\n * @param {String} isString - str if matched as a string\r\n * @return {String} - placeholder with index\r\n */\r\n\r\nfunction save (str, isString) {\r\n    var i = saved.length\r\n    saved[i] = isString\r\n        ? str.replace(newlineRE, '\\\\n')\r\n        : str\r\n    return '\"' + i + '\"'\r\n}\r\n\r\n/**\r\n * Path rewrite replacer\r\n *\r\n * @param {String} raw\r\n * @return {String}\r\n */\r\n\r\nfunction rewrite (raw) {\r\n    var c = raw.charAt(0)\r\n    var path = raw.slice(1)\r\n    if (allowedKeywordsRE.test(path)) {\r\n        return raw\r\n    } else {\r\n        path = path.indexOf('\"') > -1\r\n            ? path.replace(restoreRE, restore)\r\n            : path\r\n        return c + 'scope.' + path\r\n    }\r\n}\r\n\r\n/**\r\n * Restore replacer\r\n *\r\n * @param {String} str\r\n * @param {String} i - matched save index\r\n * @return {String}\r\n */\r\n\r\nfunction restore (str, i) {\r\n    return saved[i]\r\n}\r\n\r\nfunction compileGetter (exp) {\r\n    // if (improperKeywordsRE.test(exp)) {\r\n    //   process.env.NODE_ENV !== 'production' && warn(\r\n    //     'Avoid using reserved keywords in expression: ' + exp\r\n    //   )\r\n    // }\r\n    // reset state\r\n    saved.length = 0\r\n    // save strings and object literal keys\r\n    var body = exp\r\n        .replace(saveRE, save)\r\n        .replace(wsRE, '')\r\n    // rewrite all paths\r\n    // pad 1 space here because the regex matches 1 extra char\r\n    body = (' ' + body)\r\n        .replace(identRE, rewrite)\r\n        .replace(restoreRE, restore)\r\n    return makeGetterFn(body)\r\n}\r\n\r\nfunction makeGetterFn (body) {\r\n    return new Function('scope', 'return ' + body + ';')\r\n}\r\n\r\nexport default function parseExpression (exp, vm) {\r\n    return compileGetter(exp)(vm)\r\n}","\r\n/**\r\n * [classAttrUtil 判断绑定的class属性的结构]\r\n * @Author leegsen\r\n * @time   2018-04-03T10:58:39+0800\r\n * @param  {[type]}                 exp [description]\r\n * @return {[type]}                     [description]\r\n */\r\n// 类json结构\r\n// :class=\"{active: active}\"\r\nconst isSameJsonReg = /^\\{/\r\n// 类数组结构\r\n// :class=\"[errorClass,classType > 0 ? 'status1' : 'status0']\"\r\nconst isSameArrReg = /^\\[/\r\nexport default function classAttrUtil(exp) {\r\n    let isSameJson = isSameJsonReg.test(exp)\r\n    let isSameArr = isSameArrReg.test(exp)\r\n    // 除去外面的{},[],分割成数组\r\n    let res = exp.substring(1,exp.length - 1).split(',').map(val => {\r\n        if (isSameJson) {\r\n            let [name,nameExp] = val.split(':')\r\n            return {name,nameExp}\r\n        }\r\n        if (isSameArrReg) {\r\n            return val\r\n        }\r\n    })\r\n    return {isSameJson,isSameArr,res}\r\n}","/**\r\n * [insertAfter 在某个节点后面插入新节点]\r\n * @Author leegsen\r\n * @time   2018-04-03T17:43:19+0800\r\n * @param  {[type]}                 newElement    [description]\r\n * @param  {[type]}                 targetElement [description]\r\n * @return {[type]}                               [description]\r\n */\r\nexport default function insertAfter(newElement, targetElement) {\r\n    var parent = targetElement.parentNode; //获取目标节点的父级标签\r\n    if (parent.lastChild === targetElement) { //如果目标节点正好是最后一个节点，使用appendChild插入\r\n        parent.appendChild(newElement);\r\n    }\r\n    else {\r\n        parent.insertBefore(newElement, targetElement.nextSibling); //一般情况下要取得目标节点的下一个节点，再使用insertBefore()方法。\r\n    }\r\n    // console.log(parent)\r\n}"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtSA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;A","sourceRoot":""}